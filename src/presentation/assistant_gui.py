# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'assistant_interface.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtCore import QObject, QRunnable, QThreadPool, pyqtSignal, pyqtSlot
from presentation.mic_settings_interface import MicSettingsWindow
from interfaces.chat_handler_interface import ChatHandler

class _GenericWorker(QRunnable):
    class _GenericWorkerSignals(QObject):
        finished = pyqtSignal(object)

    def __init__(self, func, *args, **kwargs):
        super().__init__()
        self.__signals = self._GenericWorkerSignals()
        self.__func = func
        self.__args = args
        self.__kwargs = kwargs
    
    def connect_finished_signal(self, finished_signal):
        self.__signals.finished.connect(finished_signal)

    @pyqtSlot()
    def run(self):
        result = self.__func(*self.__args, **self.__kwargs)
        self.__signals.finished.emit(result)

class ChatBubble(QtWidgets.QWidget):
    __font_point_size = 11
    __border_radius = 10
    __padding_top_bottom = 8
    __padding_left_right = 8
    __max_bubble_width = int(800 * 0.85)
    def __init__(self, text, is_user, parent=None):
        super().__init__(parent)
        self._is_user = is_user
        self._text_label = QtWidgets.QLabel(text)
        self._text_label.setWordWrap(True)
        self._text_label.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)

        self._text_label.setMaximumWidth(self.__max_bubble_width)

        self.calculate_bubble_width(text)

        self._text_label.setSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred) 

        base_style = (
            f"border-radius: {self.__border_radius}px;"
            f"padding: {self.__padding_top_bottom}px {self.__padding_left_right}px;"
            f"font-size: {self.__font_point_size}pt 'Segoe UI';"
        )

        #Set bubble style
        if self._is_user:
            self._text_label.setStyleSheet(base_style + "background-color: #D0E7FF;")
        else:
            self._text_label.setStyleSheet(base_style + "background-color: #E0E0E0;")

        #Set layout
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)

        if self._is_user:
            layout.addStretch()
            layout.addWidget(self._text_label)
        else:
            layout.addWidget(self._text_label)
            layout.addStretch()

        self.setLayout(layout)
        self.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)

    def calculate_bubble_width(self, text):
        font = self._text_label.font()
        font.setPointSize(self.__font_point_size)
        metrics = QtGui.QFontMetrics(font)
        text_width_px = metrics.horizontalAdvance(text)
        bubble_padding = self.__border_radius + self.__padding_left_right * 2
        min_bubble_width = min(text_width_px + bubble_padding, self.__max_bubble_width)
        self._text_label.setMinimumWidth(min_bubble_width)

class AssistantGUI(object):

    __threadpool = QThreadPool()
    __allow_input = True

    __dot_count = 0
    __anim_timer = None
    
    def __init__(self, chat_handler: ChatHandler):
        super().__init__()
        self.__chat_handler = chat_handler

    def setupUi(self, MainWindow: QMainWindow):
        self._main_window = MainWindow
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setObjectName("widget")
        #Layout that contains checkbox
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setSpacing(0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        #Checkbox for enabling speech output
        self.checkBox = QtWidgets.QCheckBox(self.widget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox.setFont(font)
        self.checkBox.setObjectName("checkBox")
        self.checkBox.stateChanged.connect(self.__on_tts_checkbox_changed)
        self.horizontalLayout_2.addWidget(self.checkBox)
        #Chat display area
        self.verticalLayout.addWidget(self.widget)
        self.scroll_area = QtWidgets.QScrollArea(self.centralwidget)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setObjectName("scrollArea")
        self.chat_container = QtWidgets.QWidget()
        self.chat_container.setGeometry(QtCore.QRect(0, 0, 780, 480))
        self.chat_container.setObjectName("chat_container")
        self.chat_container.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Preferred)
        self.chat_layout = QtWidgets.QVBoxLayout(self.chat_container)
        self.chat_layout.setAlignment(QtCore.Qt.AlignmentFlag.AlignTop)
        self.chat_layout.setContentsMargins(0, 0, 0, 0)
        self.chat_layout.setSpacing(5)
        self.chat_layout.setObjectName("chat_layout")
        self.chat_layout.addStretch()
        self.scroll_area.setWidget(self.chat_container)
        self.verticalLayout.addWidget(self.scroll_area)
        #Layout that contains text area and buttons
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setObjectName("widget_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.widget_2)
        self.horizontalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_3.setSpacing(0)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        #Text area
        self.lineEdit = QtWidgets.QLineEdit(self.widget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit.setFont(font)
        self.lineEdit.setObjectName("lineEdit")
        self.lineEdit.returnPressed.connect(self.__send_message)
        self.horizontalLayout_3.addWidget(self.lineEdit)
        #Clear chat button
        self.pushButton_3 = QtWidgets.QPushButton(self.widget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.clicked.connect(self.__clear_chat)
        self.horizontalLayout_3.addWidget(self.pushButton_3)
        #Send text button
        self.pushButton = QtWidgets.QPushButton(self.widget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton.setFont(font)
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(self.__send_message)
        self.horizontalLayout_3.addWidget(self.pushButton)
        #Speak button and adding to layout
        self.pushButton_2 = QtWidgets.QPushButton(self.widget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(lambda: self.__send_message(True))
        self.horizontalLayout_3.addWidget(self.pushButton_2)
        self.verticalLayout.addWidget(self.widget_2)
        #Timer for animating dots
        self.__anim_timer = QtCore.QTimer(MainWindow)
        self.__anim_timer.setInterval(500) # Update dots every 500ms
        self.__anim_timer.timeout.connect(self.__update_dots)
        #Menu bar for settings
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 24))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.menubar.setFont(font)
        self.menubar.setObjectName("menubar")
        self.menuSettings = QtWidgets.QMenu(self.menubar)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.menuSettings.setFont(font)
        self.menuSettings.setObjectName("menuSettings")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionMicrophone_Settings = QtWidgets.QAction(MainWindow)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.actionMicrophone_Settings.setFont(font)
        self.actionMicrophone_Settings.setObjectName("actionMicrophone_Settings")
        self.actionMicrophone_Settings.triggered.connect(self.__open_mic_settings)
        self.menuSettings.addAction(self.actionMicrophone_Settings)
        self.menubar.addAction(self.menuSettings.menuAction())

        self.__retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def __retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Digital Assistant"))
        self.lineEdit.setPlaceholderText(_translate("MainWindow", "Type your message here..."))
        self.pushButton.setText(_translate("MainWindow", "Send"))
        self.pushButton_2.setText(_translate("MainWindow", "Speak"))
        self.pushButton_3.setText(_translate("MainWindow", "Clear Chat"))
        self.checkBox.setText(_translate("MainWindow", "Enable Speech Output"))
        self.menuSettings.setTitle(_translate("MainWindow", "Settings"))
        self.actionMicrophone_Settings.setText(_translate("MainWindow", "Microphone Settings"))

    def __open_mic_settings(self):
        self.__mic_settings_window = QtWidgets.QDialog()
        self.__mic_settings_ui = MicSettingsWindow(self.__chat_handler._sr())
        self.__mic_settings_ui.setupUi(self.__mic_settings_window)
        self.__mic_settings_window.exec_()

    def __update_dots(self):
        # Get the last item in the chat_layout. We assume it's the stretch item, 
        # and the item before that is the bubble.
        layout_count = self.chat_layout.count()
        if layout_count < 2:
            return

        # The bubble should be the second-to-last item (before the stretch item)
        bubble_item = self.chat_layout.itemAt(layout_count - 2)
        if not bubble_item:
            return

        last_bubble_widget = bubble_item.widget()
        
        # Check if the last widget is a ChatBubble and is NOT a user message
        if isinstance(last_bubble_widget, ChatBubble) and not last_bubble_widget._is_user:
            self.__dot_count = (self.__dot_count % 3) + 1
            new_dots = '.' * self.__dot_count
            
            # Update the QLabel inside the ChatBubble
            last_bubble_widget._text_label.setText(new_dots)
            
            # Use the existing scroll fix to move to the new height
            self.chat_container.adjustSize()
            QtCore.QTimer.singleShot(0, 
                lambda: self.scroll_area.verticalScrollBar().setValue(self.scroll_area.verticalScrollBar().maximum())
            )

    def __send_message(self, voiced: bool = False):
        """
        Send a message either as text or voice based on the 'voiced' parameter.
        """
        if self.__allow_input:
            if voiced:
                worker = _GenericWorker(self.__chat_handler.recognize_voice)
                worker.connect_finished_signal(self.__handle_chat_message)
                self.__set_input_enabled(False)
                self.__threadpool.start(worker)
            else:
                user_text = self.lineEdit.text().strip()
                self.__handle_chat_message(user_text)

    def __handle_chat_message(self, user_message: str | tuple[str | None, str] | None):
        if isinstance(user_message, tuple):
            text, status = user_message
            if status == "unrecognized":
                QtWidgets.QMessageBox.warning(
                    self._main_window,
                    "Speech Recognition Error",
                    "Sorry, I couldn't understand what you said.\nPlease try speaking again or use the text box instead."
                )
                self.__set_input_enabled()
                return
            elif status == "request_error":
                QtWidgets.QMessageBox.critical(
                    self._main_window,
                    "Speech Recognition Error",
                    "There was a problem connecting to the speech recognition service.\nPlease check your internet connection and try again."
                )
                self.__set_input_enabled()
                return
            user_message = text
        
        if user_message:
            self.__handle_user_message(user_message)
            self.__set_input_enabled(False)

            self.__update_chat(".", False)
            self.__dot_count = 1
            self.__anim_timer.start()

            worker = _GenericWorker(self.__chat_handler.handle_chat_message, user_message)
            worker.connect_finished_signal(self.__handle_da_response)
            self.__threadpool.start(worker)

    def __handle_user_message(self, message):
        self.__update_chat(f"{message}", True)
        self.lineEdit.clear()

    def __handle_da_response(self, response):
        self.__replace_last_da_message(f"{response}")
        self.__set_input_enabled()
        if self.checkBox.isChecked():
            worker = _GenericWorker(self.__chat_handler.start_speech, response)
            self.__threadpool.start(worker)

    def __replace_last_da_message(self, text):
        # Stop the animation timer
        if self.__anim_timer.isActive():
            self.__anim_timer.stop()
        
        layout_count = self.chat_layout.count()
        if layout_count < 2:
            # Fallback for empty chat (shouldn't happen if animation started)
            self.__update_chat(text, False)
            return

        # The bubble should be the second-to-last item (before the stretch item)
        bubble_item = self.chat_layout.itemAt(layout_count - 2)
        last_bubble_widget = bubble_item.widget()
        
        # Replace the dots with the actual response text
        if isinstance(last_bubble_widget, ChatBubble) and not last_bubble_widget._is_user:
            last_bubble_widget: ChatBubble
            last_bubble_widget.calculate_bubble_width(text)
            
            last_bubble_widget._text_label.setText(text)
            
            # Force size update and scroll to ensure the final response is fully visible
            self.chat_container.adjustSize()
            QtCore.QTimer.singleShot(0, 
                lambda: self.scroll_area.verticalScrollBar().setValue(self.scroll_area.verticalScrollBar().maximum())
            )
        else:
            # Fallback: if the last item wasn't the expected DA bubble, just add the message.
            self.__update_chat(text, False)
    
    def __update_chat(self, message, is_user_message):
        bubble = ChatBubble(message, is_user_message)
        if self.chat_layout.count() > 0 and self.chat_layout.itemAt(self.chat_layout.count() - 1).spacerItem():
            stretch = self.chat_layout.takeAt(self.chat_layout.count() - 1)
            self.chat_layout.addWidget(bubble)
            self.chat_layout.addItem(stretch)
        else:
            self.chat_layout.addWidget(bubble)
        self.chat_container.adjustSize()
        QtCore.QTimer.singleShot(0, 
            lambda: self.scroll_area.verticalScrollBar().setValue(self.scroll_area.verticalScrollBar().maximum())
        )

    def __clear_chat(self):
        while self.chat_layout.count():
            item = self.chat_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        self.__chat_handler.clear_chat_history()
    
    def __set_input_enabled(self, enabled: bool = True):
        self.__allow_input = enabled
        self.lineEdit.setEnabled(enabled)
        self.pushButton.setEnabled(enabled)
        self.pushButton_2.setEnabled(enabled)
        self.pushButton_3.setEnabled(enabled)
    
    def __on_tts_checkbox_changed(self, state):
        if state == QtCore.Qt.CheckState.Unchecked:
            worker = _GenericWorker(self.__chat_handler.stop_speech)
            self.__threadpool.start(worker)
