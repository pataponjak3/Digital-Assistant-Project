# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'assistant_interface.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtCore import QObject, QRunnable, QThreadPool, pyqtSignal, pyqtSlot
from ui.mic_settings_interface import MicSettingsWindow
from interfaces.chat_handler_interface import ChatHandler

class _GenericWorker(QRunnable):
    class _GenericWorkerSignals(QObject):
        finished = pyqtSignal(object)

    def __init__(self, func, *args, **kwargs):
        super().__init__()
        self.__signals = self._GenericWorkerSignals()
        self.__func = func
        self.__args = args
        self.__kwargs = kwargs
    
    def connect_finished_signal(self, finished_signal):
        self.__signals.finished.connect(finished_signal)

    @pyqtSlot()
    def run(self):
        result = self.__func(*self.__args, **self.__kwargs)
        self.__signals.finished.emit(result)

class ChatBubble(QtWidgets.QWidget):
    __font_pixel_size = 14
    __max_bubble_width = int(800 * 0.85)
    def __init__(self, text, is_user, parent=None):
        super().__init__(parent)
        self._is_user = is_user
        self._text_label = QtWidgets.QLabel(text)
        self._text_label.setWordWrap(True)
        self._text_label.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)

        self._text_label.setMaximumWidth(self.__max_bubble_width)

        self.calculate_bubble_width(text)

        self._text_label.setSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred) 

        base_style = (
            "border-radius: 10px;"
            "padding: 8px 12px;"
            "font-size: 14px;"
        )

        #Set bubble style
        if self._is_user:
            self._text_label.setStyleSheet(base_style + "background-color: #D0E7FF;")
        else:
            self._text_label.setStyleSheet(base_style + "background-color: #E0E0E0;")

        #Set layout
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)

        if self._is_user:
            layout.addStretch()
            layout.addWidget(self._text_label)
        else:
            layout.addWidget(self._text_label)
            layout.addStretch()

        self.setLayout(layout)
        self.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)

    def calculate_bubble_width(self, text):
        font = self._text_label.font()
        font.setPixelSize(self.__font_pixel_size)
        metrics = QtGui.QFontMetrics(font)
        text_width_px = metrics.horizontalAdvance(text)
        min_bubble_width = min(text_width_px+24+10, self.__max_bubble_width)
        self._text_label.setMinimumWidth(min_bubble_width)

class AssistantGUI(object):

    __threadpool = QThreadPool()
    __allow_input = True

    __dot_count = 0
    __anim_timer = None
    
    def __init__(self, chat_handler: ChatHandler):
        super().__init__()
        self.__chat_handler = chat_handler

    def setupUi(self, MainWindow: QMainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        MainWindow.setFixedSize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        #Chat display area
        self.scroll_area = QtWidgets.QScrollArea(self.centralwidget)
        self.scroll_area.setGeometry(QtCore.QRect(0, 20, 801, 521))
        self.scroll_area.setWidgetResizable(True)
        self.chat_container = QtWidgets.QWidget()
        self.chat_layout = QtWidgets.QVBoxLayout(self.chat_container)
        self.chat_layout.setAlignment(QtCore.Qt.AlignmentFlag.AlignTop)
        self.chat_layout.setContentsMargins(0, 0, 0, 0)
        self.chat_layout.setSpacing(5)
        self.chat_layout.addStretch()
        self.chat_container.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Preferred)
        self.scroll_area.setWidget(self.chat_container)
        #Text area
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(0, 540, 661, 20))
        self.lineEdit.setObjectName("lineEdit")
        self.lineEdit.returnPressed.connect(self.__send_message)
        #Send text button
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(720, 540, 41, 23))
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(self.__send_message)
        #Speak button
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(760, 540, 41, 23))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(lambda: self.__send_message(True))
        #Clear chat button
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(QtCore.QRect(660, 540, 61, 23))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.clicked.connect(self.__clear_chat)
        #Checkbox for enabling speech output
        self.checkBox = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox.setGeometry(QtCore.QRect(0, 0, 131, 17))
        self.checkBox.setObjectName("checkBox")
        self.checkBox.stateChanged.connect(self.__on_tts_checkbox_changed)
        MainWindow.setCentralWidget(self.centralwidget)
        #Timer for animating dots
        self.__anim_timer = QtCore.QTimer(MainWindow)
        self.__anim_timer.setInterval(500) # Update dots every 500ms
        self.__anim_timer.timeout.connect(self.__update_dots)
        #Menu bar for settings
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 21))
        self.menubar.setObjectName("menubar")
        self.menuSettings = QtWidgets.QMenu(self.menubar)
        self.menuSettings.setObjectName("menuSettings")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionMicrophone_Settings = QtWidgets.QAction(MainWindow)
        self.actionMicrophone_Settings.setObjectName("actionMicrophone_Settings")
        self.actionMicrophone_Settings.triggered.connect(self.__open_mic_settings)
        self.menuSettings.addAction(self.actionMicrophone_Settings)
        self.menubar.addAction(self.menuSettings.menuAction())

        self.__retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def __retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Digital Assistant"))
        self.lineEdit.setPlaceholderText(_translate("MainWindow", "Type your message here..."))
        self.pushButton.setText(_translate("MainWindow", "Send"))
        self.pushButton_2.setText(_translate("MainWindow", "Speak"))
        self.pushButton_3.setText(_translate("MainWindow", "Clear Chat"))
        self.checkBox.setText(_translate("MainWindow", "Enable Speech Output"))
        self.menuSettings.setTitle(_translate("MainWindow", "Settings"))
        self.actionMicrophone_Settings.setText(_translate("MainWindow", "Microphone Settings"))

    def __open_mic_settings(self):
        self.__mic_settings_window = QtWidgets.QDialog()
        self.__mic_settings_ui = MicSettingsWindow(self.__chat_handler._sr())
        self.__mic_settings_ui.setupUi(self.__mic_settings_window)
        self.__mic_settings_window.exec_()

    def __update_dots(self):
        # Get the last item in the chat_layout. We assume it's the stretch item, 
        # and the item before that is the bubble.
        layout_count = self.chat_layout.count()
        if layout_count < 2:
            return

        # The bubble should be the second-to-last item (before the stretch item)
        bubble_item = self.chat_layout.itemAt(layout_count - 2)
        if not bubble_item:
            return

        last_bubble_widget = bubble_item.widget()
        
        # Check if the last widget is a ChatBubble and is NOT a user message
        if isinstance(last_bubble_widget, ChatBubble) and not last_bubble_widget._is_user:
            self.__dot_count = (self.__dot_count % 3) + 1
            new_dots = '.' * self.__dot_count
            
            # Update the QLabel inside the ChatBubble
            last_bubble_widget._text_label.setText(new_dots)
            
            # Use the existing scroll fix to move to the new height
            self.chat_container.adjustSize()
            QtCore.QTimer.singleShot(0, 
                lambda: self.scroll_area.verticalScrollBar().setValue(self.scroll_area.verticalScrollBar().maximum())
            )

    def __send_message(self, voiced: bool = False):
        """
        Send a message either as text or voice based on the 'voiced' parameter.
        """
        if self.__allow_input:
            if voiced:
                worker = _GenericWorker(self.__chat_handler.recognize_voice)
                worker.connect_finished_signal(self.__handle_chat_message)
                self.__threadpool.start(worker)
            else:
                user_text = self.lineEdit.text().strip()
                self.__handle_chat_message(user_text)

    def __handle_chat_message(self, user_message: str | None):
        if user_message:
            self.__handle_user_message(user_message)
            self.__set_input_enabled(False)

            self.__update_chat(".", False)
            self.__dot_count = 1
            self.__anim_timer.start()

            worker = _GenericWorker(self.__chat_handler.handle_chat_message, user_message)
            worker.connect_finished_signal(self.__handle_da_response)
            self.__threadpool.start(worker)

    def __handle_user_message(self, message):
        self.__update_chat(f"{message}", True)
        self.lineEdit.clear()

    def __handle_da_response(self, response):
        self.__replace_last_da_message(f"{response}")
        self.__set_input_enabled()
        if self.checkBox.isChecked():
            worker = _GenericWorker(self.__chat_handler.start_speech, response)
            self.__threadpool.start(worker)

    def __replace_last_da_message(self, text):
        # Stop the animation timer
        if self.__anim_timer.isActive():
            self.__anim_timer.stop()
        
        layout_count = self.chat_layout.count()
        if layout_count < 2:
            # Fallback for empty chat (shouldn't happen if animation started)
            self.__update_chat(text, False)
            return

        # The bubble should be the second-to-last item (before the stretch item)
        bubble_item = self.chat_layout.itemAt(layout_count - 2)
        last_bubble_widget = bubble_item.widget()
        
        # Replace the dots with the actual response text
        if isinstance(last_bubble_widget, ChatBubble) and not last_bubble_widget._is_user:
            last_bubble_widget: ChatBubble
            last_bubble_widget.calculate_bubble_width(text)
            
            last_bubble_widget._text_label.setText(text)
            
            # Force size update and scroll to ensure the final response is fully visible
            self.chat_container.adjustSize()
            QtCore.QTimer.singleShot(0, 
                lambda: self.scroll_area.verticalScrollBar().setValue(self.scroll_area.verticalScrollBar().maximum())
            )
        else:
            # Fallback: if the last item wasn't the expected DA bubble, just add the message.
            self.__update_chat(text, False)
    
    def __update_chat(self, message, is_user_message):
        bubble = ChatBubble(message, is_user_message)
        if self.chat_layout.count() > 0 and self.chat_layout.itemAt(self.chat_layout.count() - 1).spacerItem():
            stretch = self.chat_layout.takeAt(self.chat_layout.count() - 1)
            self.chat_layout.addWidget(bubble)
            self.chat_layout.addItem(stretch)
        else:
            self.chat_layout.addWidget(bubble)
        self.chat_container.adjustSize()
        QtCore.QTimer.singleShot(0, 
            lambda: self.scroll_area.verticalScrollBar().setValue(self.scroll_area.verticalScrollBar().maximum())
        )

    def __clear_chat(self):
        while self.chat_layout.count():
            item = self.chat_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
        self.__chat_handler.clear_chat_history()
    
    def __set_input_enabled(self, enabled: bool = True):
        self.__allow_input = enabled
        self.lineEdit.setEnabled(enabled)
        self.pushButton.setEnabled(enabled)
        self.pushButton_2.setEnabled(enabled)
        self.pushButton_3.setEnabled(enabled)
    
    def __on_tts_checkbox_changed(self, state):
        if state == QtCore.Qt.CheckState.Unchecked:
            worker = _GenericWorker(self.__chat_handler.stop_speech)
            self.__threadpool.start(worker)



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = AssistantGUI()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
